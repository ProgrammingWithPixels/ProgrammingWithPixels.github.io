<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Programming with Pixels: Towards Generalist Software Engineering Agents">
  <meta name="keywords" content="software engineering, IDE, computer-use agents, PwP, programming with pixels, benchmark, multimodal">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Programming with Pixels: Towards Generalist Software Engineering Agents</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600|Roboto:400,500&display=swap" rel="stylesheet">

  <!-- CSS Stylesheets -->
  <link rel="stylesheet" href="./static/css/bulma.min.css">
  <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
  <link rel="stylesheet" href="./static/css/index.css">
  <link rel="icon" href="./static/images/favicon.svg">

  <!-- Academicons (if needed) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

  <!-- Prism for code highlighting -->
  <link rel="stylesheet" href="./static/css/prism.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>

  <!-- Custom CSS -->
  <style>
    body {
      font-family: 'Open Sans', sans-serif;
    }
    .hero {
      background-color: #f5f5f5;
      padding: 2rem 1.5rem;
    }
    .hero-body {
      padding: 3rem 1.5rem;
    }
    .section {
      padding: 3rem 1.5rem;
    }
    .title, .subtitle {
      color: #333;
    }
    .content {
      font-size: 1.125rem;
    }
    .diagram {
      border: none;
      width: 100%;
      height: auto;
    }
    .button.is-dark {
      background-color: #2C3E50;
      color: white;
    }
    .button:hover {
      opacity: 0.9;
      transition: opacity 0.2s ease;
    }
    pre {
      background: #f0f0f0;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
    }
  </style>
</head>
<body>

<!-- Hero Section -->
<section class="hero is-light">
  <div class="hero-body">
    <div class="container has-text-centered">
      <h1 class="title is-1">Programming with Pixels</h1>
      <h2 class="subtitle is-3">Towards Generalist Software Engineering Agents</h2>
      <!-- <p class="is-size-5">
        <em>Anonymous Authors • Paper under Double-Blind Review</em>
      </p> -->
      <p class="is-size-5">
        <a href="https://pranjal2041.github.io">Pranjal Aggarwal</a></sup>,
        <a href="https://sweller123.github.io/">Sean Welleck</a></sup>
      </p>
      <p class="is-size-5">Carnegie Mellon University</p>

      <br>
      <!-- Action Buttons -->
      <p class="buttons is-centered">
        <!-- Replace # with actual links when available -->
        <a href="https://arxiv.org/abs/XXXX.XXXX" class="button is-dark is-rounded">
          <span class="icon">
            <i class="ai ai-arxiv"></i>
          </span>
          <span>Paper</span>
        </a>
        <a href="https://github.com/your-repo/pwp" class="button is-dark is-rounded">
          <span class="icon"><i class="fab fa-github"></i></span>
          <span>Code</span>
        </a>
        <a href="#results" class="button is-dark is-rounded">
            <span class="icon"><i class="fas fa-chart-bar"></i></span>
            <span>Dataset</span>
          </a>
        <a href="#results" class="button is-dark is-rounded">
          <span class="icon"><i class="fas fa-chart-bar"></i></span>
          <span>Leaderboard</span>
        </a>
        <a href="mailto:contact@example.com" class="button is-dark is-rounded">
          <span class="icon"><i class="fas fa-envelope"></i></span>
          <span>Contact</span>
        </a>
      </p>
    </div>
  </div>
</section>

<!-- TLDR / Summary Section -->
<section class="section">
  <div class="container is-max-desktop">
    <h2 class="subtitle has-text-centered">
      <span style="font-weight:bold;">TLDR:</span>
      <strong>Programming with Pixels (PwP)</strong> introduces an IDE-based, computer-use agent environment that unifies software engineering tasks. By enabling agents to interact with an IDE visually—via screen observation, typing, and clicking—PwP removes the need for hand-engineered tool APIs and provides a scalable, multimodal benchmark for generalist SWE agents.
    </h2>
  </div>
</section>

<!-- Abstract Section -->
<section class="section has-background-light" id="abstract">
  <div class="container">
    <h2 class="title is-3 has-text-centered">Abstract</h2>
    <div class="content">
      <p class="is-size-5">
        Recent advancements in software engineering (SWE) agents have largely followed a tool‐based paradigm,
        where agents interact with hand‐engineered tool APIs to perform specific tasks. While effective for specialized tasks, these methods fundamentally lack generalization across programming languages and domains. We introduce <strong>Programming with Pixels (PwP)</strong>,
        an agent environment that unifies software development tasks by enabling computer‐use agents to interact directly within an IDE via visual perception, typing, and clicking. To systematically evaluate these agents, we propose <strong>PwP-Bench</strong>, a benchmark unifying diverse SWE tasks across multiple languages and modalities. Our experiments show that general-purpose computer-use agents can approach—and in some cases even exceed—the performance of specialized tool-based agents, highlighting the untapped potential of leveraging built-in IDE functionalities.
      </p>
    </div>
  </div>
</section>

<!-- Introduction Section -->
<section class="section" id="introduction">
  <div class="container">
    <h2 class="title is-3">1. Introduction</h2>
    <div class="content">
      <p class="is-size-5">
        Human developers excel at seamlessly navigating between programming languages, tools, and domains.
        In contrast, most current software engineering agents depend on predefined tool APIs that constrain their flexibility.
        Our motivating hypothesis is that enabling agents to interact with computers as humans do—by observing the screen,
        typing, and clicking—will yield more general and scalable SWE agents. In this work, we recast agentic software engineering as direct interaction with an IDE, allowing agents to leverage all available tools without bespoke engineering.
      </p>
      <p class="is-size-5">
        In the following sections, we introduce the <strong>PwP environment</strong>, detail its key features,
        describe our comprehensive benchmark (<strong>PwP-Bench</strong>), and present experimental results
        comparing generalist computer-use agents to traditional tool-based agents.
      </p>
    </div>
  </div>
</section>

<!-- PwP Environment Section -->
<section class="section has-background-light" id="pwp-environment">
  <div class="container">
    <h2 class="title is-3 has-text-centered">Programming with Pixels (PwP) Environment</h2>
    <figure class="image">
      <img src="./static/images/pwp_diagram.png" alt="PwP Environment Diagram" class="diagram">
    </figure>
    <div class="content">
      <p class="is-size-5">
        The PwP environment models an IDE (e.g., a customized VSCode) as a partially observable Markov decision process (POMDP). Agents interact with the IDE through primitive actions like mouse clicks and keyboard inputs,
        while observations are obtained via screenshots and interface element annotations. This expressive observation and action space
        allows agents to perform any task achievable by a human developer, from code generation to debugging.
      </p>
      <ul class="is-size-5">
        <li><strong>Expressive Interaction:</strong> Agents observe and act on the full visual state of the IDE.</li>
        <li><strong>Full Tool Support:</strong> Leverages built-in IDE functionalities such as debuggers, linters, and version control.</li>
        <li><strong>Multimodal Inputs:</strong> Supports text, images, and even video streams, enabling diverse SWE tasks.</li>
        <li><strong>Execution-Based Evaluation:</strong> Tasks are evaluated via automated tests, ensuring real-world applicability.</li>
      </ul>
    </div>
  </div>
</section>

<!-- PwP-Bench Section -->
<section class="section" id="benchmark">
  <div class="container">
    <h2 class="title is-3 has-text-centered">PwP-Bench: A Unified SWE Benchmark</h2>
    <div class="content">
      <p class="is-size-5">
        To evaluate computer-use agents in realistic scenarios, we introduce <strong>PwP-Bench</strong> – a comprehensive benchmark spanning 15 tasks
        from code generation and editing to UI design and DevOps workflows. PwP-Bench unifies diverse SWE challenges across multiple programming languages,
        modalities, and domains, offering a scalable testbed for developing and comparing generalist SWE agents.
      </p>
      <p class="is-size-5">
        Figure 1 (below) illustrates a comparison between traditional tool-based paradigms and our PwP framework, highlighting the advantage of
        direct IDE interaction.
      </p>
      <figure class="image">
        <img src="./static/images/pwp_comparison.png" alt="Comparison between Tool-Based and PwP Paradigms" class="diagram">
      </figure>
    </div>
  </div>
</section>

<!-- Experiments & Analysis Section -->
<section class="section has-background-light" id="results">
  <div class="container">
    <h2 class="title is-3 has-text-centered">Experiments & Analysis</h2>
    <div class="content">
      <p class="is-size-5">
        We evaluate state-of-the-art vision-language models using two agent configurations:
        <strong>Computer-Use Agents</strong> (relying solely on UI interactions) and <strong>Assisted Agents</strong> (with access to file and bash APIs).
        Our experiments on PwP-Bench-Lite (a curated subset of 300 instances) reveal that while raw visual input yields limited performance,
        granting agents direct access to IDE tools substantially improves outcomes.
      </p>
      <p class="is-size-5">
        For example, the best-performing model achieves up to 47.2% overall accuracy when assisted, compared to near-zero performance in certain categories when relying solely on screenshots.
      </p>
      <figure class="image">
        <img src="./static/images/pwp_results.png" alt="PwP Performance Chart" class="diagram">
      </figure>
    </div>
  </div>
</section>

<!-- BibTeX Section -->
<section class="section" id="bibtex">
  <div class="container is-max-desktop content">
    <h2 class="title is-3">BibTeX</h2>
    <pre><code>@misc{anonymous2024pwp,
  title = {Programming with Pixels: Towards Generalist Software Engineering Agents},
  author = {Anonymous},
  note = {Paper under double-blind review},
  year = {2024},
  url = {https://arxiv.org/abs/XXXX.XXXX}
}</code></pre>
  </div>
</section>

<!-- Footer -->
<footer class="footer">
  <div class="content has-text-centered">
    <p>
      <strong>Programming with Pixels</strong> &mdash; a unified platform for evaluating generalist SWE agents.
    </p>
    <p>
      <a href="https://arxiv.org/abs/XXXX.XXXX" class="icon">
        <i class="fas fa-file-alt"></i>
      </a>
      &nbsp;
      <a href="https://github.com/your-repo/pwp" class="icon">
        <i class="fab fa-github"></i>
      </a>
    </p>
    <br>
    <p>
      Template adapted from Nerfies by Keunhong Park et al. and built using <a href="https://bulma.io/">Bulma</a>.
    </p>
  </div>
</footer>

<!-- JavaScript for Tabs (if needed for future interactive sections) -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Tab switching code if additional tabbed content is added in the future.
    const tabSections = document.querySelectorAll('.tabs');
    tabSections.forEach(tabSection => {
      const allTabs = tabSection.querySelectorAll('ul li');
      allTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const target = tab.dataset.tab;
          allTabs.forEach(t => t.classList.remove('is-active'));
          tab.classList.add('is-active');
          const container = tabSection.closest('.container');
          const tabContents = container.querySelectorAll('.tab-content');
          tabContents.forEach(content => {
            content.classList.toggle('is-active', content.id === target);
          });
        });
      });
    });
  });
</script>

</body>
</html>